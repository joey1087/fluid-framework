//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: src-delomboked/com/sponberg/fluid/datastore/DatastoreManager.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "com/sponberg/fluid/FluidApp.h"
#include "com/sponberg/fluid/GlobalState.h"
#include "com/sponberg/fluid/ResourceService.h"
#include "com/sponberg/fluid/SecurityService.h"
#include "com/sponberg/fluid/datastore/DatastoreException.h"
#include "com/sponberg/fluid/datastore/DatastoreManager.h"
#include "com/sponberg/fluid/datastore/DatastoreService.h"
#include "com/sponberg/fluid/datastore/DatastoreVersion.h"
#include "com/sponberg/fluid/datastore/FluidDatastoreParameters.h"
#include "com/sponberg/fluid/datastore/SQLQuery.h"
#include "com/sponberg/fluid/datastore/SQLQueryDefault.h"
#include "com/sponberg/fluid/datastore/SQLResultList.h"
#include "com/sponberg/fluid/datastore/SQLWhereClause.h"
#include "com/sponberg/fluid/datastore/UpgradeListener.h"
#include "com/sponberg/fluid/util/KVLReader.h"
#include "com/sponberg/fluid/util/KeyValueList.h"
#include "com/sponberg/fluid/util/Logger.h"
#include "java/io/BufferedReader.h"
#include "java/io/IOException.h"
#include "java/io/Reader.h"
#include "java/io/StringReader.h"
#include "java/lang/Integer.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/StringBuilder.h"
#include "java/util/ArrayList.h"
#include "java/util/Collection.h"
#include "java/util/HashMap.h"
#include "java/util/List.h"

@implementation FFTDatastoreManager

- (void)load__WithFFTFluidApp:(FFTFluidApp *)app {
  settings_ = [((id<JavaUtilList>) nil_chk([((FFTKVLReader *) nil_chk([((FFTFluidApp *) nil_chk(app)) getSettings])) getWithNSString:@"datastore"])) getWithInt:0];
  if (![((NSString *) nil_chk([((id<FFTKeyValueList>) nil_chk(settings_)) getValue])) isEqual:@"settings"]) {
    @throw [[JavaLangRuntimeException alloc] initWithNSString:@"Invalid settings under logging"];
  }
  if (![((NSString *) nil_chk([settings_ getValueWithNSString:@"enabled"])) equalsIgnoreCase:@"true"]) {
    return;
  }
  enabled_ = YES;
  defaultDatabaseName_ = [settings_ getValueWithNSString:@"default-database"];
  [self populateDatabasesMap];
  if ([app getDatastoreService] == nil) {
    @throw [[JavaLangRuntimeException alloc] initWithNSString:@"DatastoreService not initialized"];
  }
  for (FFTDatastoreManager_Database * __strong database in nil_chk([((JavaUtilHashMap *) nil_chk(databases_)) values])) {
    [self createOrUpdateDatabaseWithFFTDatastoreManager_Database:database withFFTFluidApp:app];
  }
  upgradeListeners_ = nil;
}

- (void)createOrUpdateDatabaseWithFFTDatastoreManager_Database:(FFTDatastoreManager_Database *)database
                                               withFFTFluidApp:(FFTFluidApp *)app {
  id<FFTDatastoreService> ds = [((FFTFluidApp *) nil_chk(app)) getDatastoreService];
  @try {
    [self populateVersionListWithFFTDatastoreManager_Database:database];
    if ([((id<FFTDatastoreService>) nil_chk(ds)) doesBackupExistWithNSString:[((FFTDatastoreManager_Database *) nil_chk(database)) getDatabaseName]]) {
      [ds restoreBackupWithNSString:[database getDatabaseName]];
    }
    BOOL databaseExists = NO;
    if (![ds doesDatabaseExistWithNSString:[database getDatabaseName]]) {
      databaseExists = [ds deployDatabaseFromBundleWithNSString:[database getDatabaseName]];
    }
    [ds openDatabaseWithNSString:[database getDatabaseName]];
    BOOL ignoreHashMismatch = NO;
    id<FFTSecurityService> ss = [((FFTFluidApp *) nil_chk(FFTGlobalState_get_fluidApp__())) getSecurityService];
    if (![((id<FFTSecurityService>) nil_chk(ss)) hasUserSalt]) {
      ignoreHashMismatch = YES;
    }
    BOOL databaseSchemaExists = databaseExists ? YES : [self doesSchemaExist];
    if (!databaseSchemaExists) {
      [ds closeDatabase];
      [ds deleteDatabaseWithNSString:[database getDatabaseName]];
      [ds openDatabaseWithNSString:[database getDatabaseName]];
      [FFTLogger debugWithId:self withNSString:@"Database schema doesn't exist, creating database now: {}" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [database getDatabaseName] } count:1 type:[IOSClass classWithClass:[NSObject class]]]];
      [self createDatabaseWithFFTDatastoreManager_Database:database withFFTFluidApp:app];
    }
    FFTDatastoreVersion *versionOfDatabase = [self getVersionOfDatabaseWithBoolean:ignoreHashMismatch];
    if (databaseSchemaExists && ignoreHashMismatch) {
      [self setDatastoreVersionWithFFTDatastoreVersion:versionOfDatabase];
    }
    [FFTLogger debugWithId:self withNSString:@"Version of database on device is {}, current version is {}" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ versionOfDatabase, database->currentVersion_ } count:2 type:[IOSClass classWithClass:[NSObject class]]]];
    if ([((FFTDatastoreVersion *) nil_chk(versionOfDatabase)) compareToWithId:database->currentVersion_] < 0) {
      [self upgradeDatabaseWithFFTDatastoreManager_Database:database withFFTFluidApp:app withFFTDatastoreVersion:versionOfDatabase];
    }
    [ds closeDatabase];
  }
  @catch (FFTDatastoreException *e) {
    [FFTLogger errorWithId:self withJavaLangThrowable:e];
    @throw [[JavaLangRuntimeException alloc] initWithJavaLangThrowable:e];
  }
}

- (void)createDatabaseWithFFTDatastoreManager_Database:(FFTDatastoreManager_Database *)database
                                       withFFTFluidApp:(FFTFluidApp *)app {
  id<FFTDatastoreService> ds = [((FFTFluidApp *) nil_chk(app)) getDatastoreService];
  [((id<FFTDatastoreService>) nil_chk(ds)) startTransaction];
  FFTDatastoreVersion *firstVersion = [((JavaUtilArrayList *) nil_chk(((FFTDatastoreManager_Database *) nil_chk(database))->versions_)) getWithInt:0];
  NSString *fileSuffix = [self getVersionFileSuffixWithFFTDatastoreVersion:firstVersion];
  NSString *fileName = [NSString stringWithFormat:@"%@_create%@", [database getSimpleName], fileSuffix];
  [FFTLogger debugWithId:self withNSString:@"Opening {}" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ fileName } count:1 type:[IOSClass classWithClass:[NSObject class]]]];
  NSString *createStatements = [((id<FFTResourceService>) nil_chk([app getResourceService])) getResourceAsStringWithNSString:@"sql" withNSString:fileName];
  [self executeRawStatementsWithNSString:createStatements];
  NSString *create = [NSString stringWithFormat:@"create table %@ ( %@ text unique on conflict replace, %@ text, %@ int);", FFTFluidDatastoreParameters_get_kFluidParameterTable_(), FFTFluidDatastoreParameters_get_kParameterKey_(), FFTFluidDatastoreParameters_get_kParameterValue_(), FFTFluidDatastoreParameters_get_kParameterRowHash_()];
  [ds executeRawStatementWithNSString:create];
  [self setDatastoreVersionWithFFTDatastoreVersion:[[FFTDatastoreVersion alloc] initWithInt:0 withInt:0]];
  [ds commitTransaction];
  [self notifyUpgradeListenerWithFFTDatastoreManager_Database:database withFFTDatastoreService:ds withFFTDatastoreVersion:firstVersion];
  [self setDatastoreVersionWithFFTDatastoreVersion:firstVersion];
}

- (void)notifyUpgradeListenerWithFFTDatastoreManager_Database:(FFTDatastoreManager_Database *)database
                                      withFFTDatastoreService:(id<FFTDatastoreService>)ds
                                      withFFTDatastoreVersion:(FFTDatastoreVersion *)toVersion {
  id<FFTUpgradeListener> listener = nil;
  JavaUtilHashMap *map = [((JavaUtilHashMap *) nil_chk(upgradeListeners_)) getWithId:[((FFTDatastoreManager_Database *) nil_chk(database)) getSimpleName]];
  if (map != nil) {
    listener = [map getWithId:toVersion];
  }
  if (listener != nil) {
    [((id<FFTDatastoreService>) nil_chk(ds)) closeDatabase];
    BOOL success = [listener databaseWasUpgradedWithFFTDatastoreVersion:toVersion];
    if (!success) {
      @throw [[FFTDatastoreException alloc] initWithNSString:[NSString stringWithFormat:@"User aborted upgrade with listener on version %@", toVersion]];
    }
    [ds openDatabaseWithNSString:[database getDatabaseName]];
  }
}

- (void)upgradeDatabaseWithFFTDatastoreManager_Database:(FFTDatastoreManager_Database *)database
                                        withFFTFluidApp:(FFTFluidApp *)app
                                withFFTDatastoreVersion:(FFTDatastoreVersion *)fromVersion {
  id<FFTDatastoreService> ds = [((FFTFluidApp *) nil_chk(app)) getDatastoreService];
  [((id<FFTDatastoreService>) nil_chk(ds)) backupDatabaseWithNSString:[((FFTDatastoreManager_Database *) nil_chk(database)) getDatabaseName]];
  @try {
    [self upgradeDatabaseHelperWithFFTDatastoreManager_Database:database withFFTFluidApp:app withFFTDatastoreVersion:fromVersion];
    [ds deleteBackupWithNSString:[database getDatabaseName]];
  }
  @catch (FFTDatastoreException *e) {
    [ds closeDatabase];
    [ds restoreBackupWithNSString:[database getDatabaseName]];
    @throw e;
  }
}

- (void)upgradeDatabaseHelperWithFFTDatastoreManager_Database:(FFTDatastoreManager_Database *)database
                                              withFFTFluidApp:(FFTFluidApp *)app
                                      withFFTDatastoreVersion:(FFTDatastoreVersion *)fromVersion {
  BOOL performUpgrade = NO;
  FFTDatastoreVersion *lastUpgrade = [[FFTDatastoreVersion alloc] initWithInt:0 withInt:0];
  for (FFTDatastoreVersion * __strong v in nil_chk(((FFTDatastoreManager_Database *) nil_chk(database))->versions_)) {
    if ([((FFTDatastoreVersion *) nil_chk(v)) compareToWithId:database->currentVersion_] > 0) {
      @throw [[JavaLangRuntimeException alloc] initWithNSString:[NSString stringWithFormat:@"Version can't be higher than current version %@", v]];
    }
    if (performUpgrade) {
      if ([v compareToWithId:fromVersion] <= 0) {
        @throw [[JavaLangRuntimeException alloc] initWithNSString:[NSString stringWithFormat:@"Version to upgrade to must be higher than datastore version %@", v]];
      }
      if ([v compareToWithId:lastUpgrade] <= 0) {
        @throw [[JavaLangRuntimeException alloc] initWithNSString:[NSString stringWithFormat:@"Version must be higher than last upgrade version %@", v]];
      }
      [self upgradeDatabaseVersionWithFFTDatastoreManager_Database:database withFFTFluidApp:app withFFTDatastoreVersion:v];
      lastUpgrade = v;
      if (v == database->currentVersion_) {
        break;
      }
    }
    else if ([((FFTDatastoreVersion *) nil_chk(fromVersion)) isEqual:v]) {
      performUpgrade = YES;
    }
  }
}

- (void)upgradeDatabaseVersionWithFFTDatastoreManager_Database:(FFTDatastoreManager_Database *)database
                                               withFFTFluidApp:(FFTFluidApp *)app
                                       withFFTDatastoreVersion:(FFTDatastoreVersion *)version_ {
  [FFTLogger debugWithId:self withNSString:@"Upgrading database {} to {}" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [((FFTDatastoreManager_Database *) nil_chk(database)) getSimpleName], version_ } count:2 type:[IOSClass classWithClass:[NSObject class]]]];
  NSString *fileSuffix = [self getVersionFileSuffixWithFFTDatastoreVersion:version_];
  NSString *createStatements = [((id<FFTResourceService>) nil_chk([((FFTFluidApp *) nil_chk(app)) getResourceService])) getResourceAsStringWithNSString:@"sql" withNSString:[NSString stringWithFormat:@"%@_upgrade%@", [database getSimpleName], fileSuffix]];
  id<FFTDatastoreService> ds = [((FFTFluidApp *) nil_chk(FFTGlobalState_get_fluidApp__())) getDatastoreService];
  [((id<FFTDatastoreService>) nil_chk(ds)) startTransaction];
  [self executeRawStatementsWithNSString:createStatements];
  [ds commitTransaction];
  [self notifyUpgradeListenerWithFFTDatastoreManager_Database:database withFFTDatastoreService:ds withFFTDatastoreVersion:version_];
  [self setDatastoreVersionWithFFTDatastoreVersion:database->currentVersion_];
}

- (void)executeRawStatementsWithNSString:(NSString *)statements {
  id<FFTDatastoreService> ds = [((FFTFluidApp *) nil_chk(FFTGlobalState_get_fluidApp__())) getDatastoreService];
  for (NSString * __strong createStatement in nil_chk([self getIndividualCreateStatementsWithNSString:statements])) {
    [((id<FFTDatastoreService>) nil_chk(ds)) executeRawStatementWithNSString:createStatement];
  }
}

- (void)setDatastoreVersionWithFFTDatastoreVersion:(FFTDatastoreVersion *)datastoreVersion {
  NSString *formattedNumber = [self formatVersionNumberWithFFTDatastoreVersion:datastoreVersion];
  [FFTFluidDatastoreParameters setValueWithNSString:FFTFluidDatastoreParameters_get_kDsVersion_() withNSString:formattedNumber];
}

- (FFTDatastoreVersion *)parseVersionNumberWithNSString:(NSString *)version_ {
  IOSObjectArray *versionTokens = [((NSString *) nil_chk(version_)) split:@"\\."];
  int majorVersion = [JavaLangInteger parseIntWithNSString:IOSObjectArray_Get(nil_chk(versionTokens), 0)];
  int minorVersion = [JavaLangInteger parseIntWithNSString:IOSObjectArray_Get(versionTokens, 1)];
  if (minorVersion > 99) {
    @throw [[JavaLangRuntimeException alloc] initWithNSString:@"Minor version must be <= 99"];
  }
  return [[FFTDatastoreVersion alloc] initWithInt:majorVersion withInt:minorVersion];
}

- (NSString *)formatVersionNumberWithFFTDatastoreVersion:(FFTDatastoreVersion *)version_ {
  return [NSString stringWithFormat:@"%@.%@", [NSString formatWithNSString:@"%02d" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [JavaLangInteger valueOfWithInt:[((FFTDatastoreVersion *) nil_chk(version_)) getMajorVersion]] } count:1 type:[IOSClass classWithClass:[NSObject class]]]], [NSString formatWithNSString:@"%02d" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [JavaLangInteger valueOfWithInt:[version_ getMinorVersion]] } count:1 type:[IOSClass classWithClass:[NSObject class]]]]];
}

- (NSString *)getVersionFileSuffixWithFFTDatastoreVersion:(FFTDatastoreVersion *)version_ {
  NSString *versionPart = [((NSString *) nil_chk([self formatVersionNumberWithFFTDatastoreVersion:version_])) replaceAll:@"\\." withReplacement:@"_"];
  return [NSString stringWithFormat:@"_%@.sql", versionPart];
}

- (id<JavaUtilList>)getIndividualCreateStatementsWithNSString:(NSString *)createStatements {
  JavaUtilArrayList *statements = [[JavaUtilArrayList alloc] init];
  JavaLangStringBuilder *builder = [[JavaLangStringBuilder alloc] init];
  JavaIoReader *in = [[JavaIoBufferedReader alloc] initWithJavaIoReader:[[JavaIoStringReader alloc] initWithNSString:createStatements]];
  BOOL openSingleQuote = NO;
  BOOL openDoubleQuote = NO;
  @try {
    int c;
    while ((c = [in read]) != -1) {
      (void) [builder appendWithChar:(unichar) c];
      if (c == ';' && !openSingleQuote && !openDoubleQuote) {
        [statements addWithId:[((NSString *) nil_chk([builder description])) trim]];
        builder = [[JavaLangStringBuilder alloc] init];
        continue;
      }
      if (c == '\'' && !openDoubleQuote) {
        openSingleQuote = !openSingleQuote;
      }
      else if (c == '"' && !openSingleQuote) {
        openDoubleQuote = !openDoubleQuote;
      }
    }
  }
  @catch (JavaIoIOException *e) {
    [FFTLogger errorWithId:self withJavaLangThrowable:e];
  }
  return statements;
}

- (BOOL)doesSchemaExist {
  id<FFTDatastoreService> ds = [((FFTFluidApp *) nil_chk(FFTGlobalState_get_fluidApp__())) getDatastoreService];
  FFTSQLQuery *query = [[FFTSQLQueryDefault alloc] initWithNSString:@"sqlite_master" withNSStringArray:[IOSObjectArray arrayWithObjects:(id[]){ @"name" } count:1 type:[IOSClass classWithClass:[NSString class]]]];
  [query setWhereWithNSString:@"{} = ? and {} = ?"];
  [((FFTSQLWhereClause *) nil_chk([query getWhere])) addStringParameterWithNSString:@"type" withNSString:@"table"];
  [((FFTSQLWhereClause *) nil_chk([query getWhere])) addStringParameterWithNSString:@"name" withNSString:FFTFluidDatastoreParameters_get_kFluidParameterTable_()];
  BOOL hasTable = [((FFTSQLResultList *) nil_chk([((id<FFTDatastoreService>) nil_chk(ds)) queryWithFFTSQLQuery:query])) hasNext];
  if (hasTable) {
    NSString *dbVersion = [FFTFluidDatastoreParameters getValueWithNSString:FFTFluidDatastoreParameters_get_kDsVersion_()];
    if (dbVersion == nil || [dbVersion isEqual:@"00.00"]) {
      return NO;
    }
    else {
      return YES;
    }
  }
  else {
    return NO;
  }
}

- (FFTDatastoreVersion *)getVersionOfDatabaseWithBoolean:(BOOL)ignoreHashMismatch {
  id<FFTDatastoreService> ds = [((FFTFluidApp *) nil_chk(FFTGlobalState_get_fluidApp__())) getDatastoreService];
  FFTSQLQuery *query = [[FFTSQLQueryDefault alloc] initWithNSString:@"sqlite_master" withNSStringArray:[IOSObjectArray arrayWithObjects:(id[]){ @"name" } count:1 type:[IOSClass classWithClass:[NSString class]]]];
  [query setWhereWithNSString:@"{} = ? and {} = ?"];
  [((FFTSQLWhereClause *) nil_chk([query getWhere])) addStringParameterWithNSString:@"type" withNSString:@"table"];
  [((FFTSQLWhereClause *) nil_chk([query getWhere])) addStringParameterWithNSString:@"name" withNSString:FFTFluidDatastoreParameters_get_kFluidParameterTable_()];
  FFTSQLResultList *list = [((id<FFTDatastoreService>) nil_chk(ds)) queryWithFFTSQLQuery:query];
  if (![((FFTSQLResultList *) nil_chk(list)) hasNext]) {
    @throw [[JavaLangRuntimeException alloc] initWithNSString:@"Database is missing internal fluid table"];
  }
  else {
    NSString *dbVersion = [FFTFluidDatastoreParameters getValueWithNSString:FFTFluidDatastoreParameters_get_kDsVersion_()];
    if (dbVersion == nil) {
      @throw [[JavaLangRuntimeException alloc] initWithNSString:@"Missing dbVersion"];
    }
    return [self parseVersionNumberWithNSString:dbVersion];
  }
}

- (void)populateVersionListWithFFTDatastoreManager_Database:(FFTDatastoreManager_Database *)database {
  NSString *versionFileString = [((id<FFTResourceService>) nil_chk([((FFTFluidApp *) nil_chk(FFTGlobalState_get_fluidApp__())) getResourceService])) getResourceAsStringWithNSString:@"generated" withNSString:[NSString stringWithFormat:@"datastoreVersions_%@.txt", [((FFTDatastoreManager_Database *) nil_chk(database)) getSimpleName]]];
  JavaIoBufferedReader *in = [[JavaIoBufferedReader alloc] initWithJavaIoReader:[[JavaIoStringReader alloc] initWithNSString:versionFileString]];
  NSString *line;
  @try {
    while ((line = [in readLine]) != nil) {
      [((JavaUtilArrayList *) nil_chk(database->versions_)) addWithId:[self parseVersionNumberWithNSString:line]];
    }
  }
  @catch (JavaIoIOException *e) {
    @throw [[JavaLangRuntimeException alloc] initWithJavaLangThrowable:e];
  }
  database->currentVersion_ = [database->versions_ getWithInt:[((JavaUtilArrayList *) nil_chk(database->versions_)) size] - 1];
}

- (void)populateDatabasesMap {
  NSString *versionFileString = [((id<FFTResourceService>) nil_chk([((FFTFluidApp *) nil_chk(FFTGlobalState_get_fluidApp__())) getResourceService])) getResourceAsStringWithNSString:@"generated" withNSString:@"datastores.txt"];
  JavaIoBufferedReader *in = [[JavaIoBufferedReader alloc] initWithJavaIoReader:[[JavaIoStringReader alloc] initWithNSString:versionFileString]];
  NSString *line;
  @try {
    while ((line = [in readLine]) != nil) {
      (void) [((JavaUtilHashMap *) nil_chk(databases_)) putWithId:line withId:[[FFTDatastoreManager_Database alloc] initWithNSString:line]];
    }
  }
  @catch (JavaIoIOException *e) {
    @throw [[JavaLangRuntimeException alloc] initWithJavaLangThrowable:e];
  }
}

- (FFTDatastoreManager_Database *)getDefaultDatabase {
  return [((JavaUtilHashMap *) nil_chk(databases_)) getWithId:defaultDatabaseName_];
}

- (FFTDatastoreManager_Database *)getDatabaseWithNSString:(NSString *)databaseName {
  return [((JavaUtilHashMap *) nil_chk(databases_)) getWithId:databaseName];
}

- (id<JavaUtilCollection>)getDatabases {
  return [((JavaUtilHashMap *) nil_chk(databases_)) values];
}

- (void)setUpgradeListenerWithFFTDatastoreVersion:(FFTDatastoreVersion *)toVersion
                           withFFTUpgradeListener:(id<FFTUpgradeListener>)listener {
  NSString *databaseSimpleName = [((id<FFTUpgradeListener>) nil_chk(listener)) getDatastoreName];
  JavaUtilHashMap *map = [((JavaUtilHashMap *) nil_chk(upgradeListeners_)) getWithId:databaseSimpleName];
  if (map == nil) {
    map = [[JavaUtilHashMap alloc] init];
    (void) [upgradeListeners_ putWithId:databaseSimpleName withId:map];
  }
  if ([((JavaUtilHashMap *) nil_chk(map)) containsKeyWithId:toVersion]) {
    [FFTLogger warnWithId:self withNSString:@"Setting the upgrade listener, but it was already set. Replacing it {} {}" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ databaseSimpleName, toVersion } count:2 type:[IOSClass classWithClass:[NSObject class]]]];
  }
  (void) [map putWithId:toVersion withId:listener];
}

- (IOSObjectArray *)getSupportedPlatforms {
  return nil;
}

- (BOOL)isEnabled {
  return self->enabled_;
}

- (NSString *)getDefaultDatabaseName {
  return self->defaultDatabaseName_;
}

- (id)init {
  if (self = [super init]) {
    enabled_ = NO;
    databases_ = [[JavaUtilHashMap alloc] init];
    upgradeListeners_ = [[JavaUtilHashMap alloc] init];
  }
  return self;
}

- (void)copyAllFieldsTo:(FFTDatastoreManager *)other {
  [super copyAllFieldsTo:other];
  other->databases_ = databases_;
  other->defaultDatabaseName_ = defaultDatabaseName_;
  other->enabled_ = enabled_;
  other->settings_ = settings_;
  other->upgradeListeners_ = upgradeListeners_;
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "load__WithFFTFluidApp:", "load", "V", 0x1, NULL },
    { "createOrUpdateDatabaseWithFFTDatastoreManager_Database:withFFTFluidApp:", "createOrUpdateDatabase", "V", 0x4, "Lcom.sponberg.fluid.datastore.DatastoreException;" },
    { "createDatabaseWithFFTDatastoreManager_Database:withFFTFluidApp:", "createDatabase", "V", 0x2, "Lcom.sponberg.fluid.datastore.DatastoreException;" },
    { "notifyUpgradeListenerWithFFTDatastoreManager_Database:withFFTDatastoreService:withFFTDatastoreVersion:", "notifyUpgradeListener", "V", 0x2, NULL },
    { "upgradeDatabaseWithFFTDatastoreManager_Database:withFFTFluidApp:withFFTDatastoreVersion:", "upgradeDatabase", "V", 0x2, "Lcom.sponberg.fluid.datastore.DatastoreException;" },
    { "upgradeDatabaseHelperWithFFTDatastoreManager_Database:withFFTFluidApp:withFFTDatastoreVersion:", "upgradeDatabaseHelper", "V", 0x2, "Lcom.sponberg.fluid.datastore.DatastoreException;" },
    { "upgradeDatabaseVersionWithFFTDatastoreManager_Database:withFFTFluidApp:withFFTDatastoreVersion:", "upgradeDatabaseVersion", "V", 0x2, "Lcom.sponberg.fluid.datastore.DatastoreException;" },
    { "executeRawStatementsWithNSString:", "executeRawStatements", "V", 0x2, "Lcom.sponberg.fluid.datastore.DatastoreException;" },
    { "setDatastoreVersionWithFFTDatastoreVersion:", "setDatastoreVersion", "V", 0x2, "Lcom.sponberg.fluid.datastore.DatastoreException;" },
    { "parseVersionNumberWithNSString:", "parseVersionNumber", "Lcom.sponberg.fluid.datastore.DatastoreVersion;", 0x2, NULL },
    { "formatVersionNumberWithFFTDatastoreVersion:", "formatVersionNumber", "Ljava.lang.String;", 0x2, NULL },
    { "getVersionFileSuffixWithFFTDatastoreVersion:", "getVersionFileSuffix", "Ljava.lang.String;", 0x2, NULL },
    { "getIndividualCreateStatementsWithNSString:", "getIndividualCreateStatements", "Ljava.util.List;", 0x2, NULL },
    { "doesSchemaExist", NULL, "Z", 0x2, "Lcom.sponberg.fluid.datastore.DatastoreException;" },
    { "getVersionOfDatabaseWithBoolean:", "getVersionOfDatabase", "Lcom.sponberg.fluid.datastore.DatastoreVersion;", 0x2, "Lcom.sponberg.fluid.datastore.DatastoreException;" },
    { "populateVersionListWithFFTDatastoreManager_Database:", "populateVersionList", "V", 0x2, NULL },
    { "populateDatabasesMap", NULL, "V", 0x4, NULL },
    { "getDefaultDatabase", NULL, "Lcom.sponberg.fluid.datastore.DatastoreManager$Database;", 0x1, NULL },
    { "getDatabaseWithNSString:", "getDatabase", "Lcom.sponberg.fluid.datastore.DatastoreManager$Database;", 0x1, NULL },
    { "getDatabases", NULL, "Ljava.util.Collection;", 0x1, NULL },
    { "setUpgradeListenerWithFFTDatastoreVersion:withFFTUpgradeListener:", "setUpgradeListener", "V", 0x1, NULL },
    { "getSupportedPlatforms", NULL, "[Ljava.lang.String;", 0x1, NULL },
    { "isEnabled", NULL, "Z", 0x1, NULL },
    { "getDefaultDatabaseName", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "init", NULL, NULL, 0x1, NULL },
  };
  static J2ObjcFieldInfo fields[] = {
    { "settings_", NULL, 0x0, "Lcom.sponberg.fluid.util.KeyValueList;", NULL,  },
    { "enabled_", NULL, 0x4, "Z", NULL,  },
    { "defaultDatabaseName_", NULL, 0x4, "Ljava.lang.String;", NULL,  },
    { "databases_", NULL, 0x4, "Ljava.util.HashMap;", NULL,  },
    { "upgradeListeners_", NULL, 0x4, "Ljava.util.HashMap;", NULL,  },
  };
  static J2ObjcClassInfo _FFTDatastoreManager = { "DatastoreManager", "com.sponberg.fluid.datastore", NULL, 0x1, 25, methods, 5, fields, 0, NULL};
  return &_FFTDatastoreManager;
}

@end

@implementation FFTDatastoreManager_Database

- (id)initWithNSString:(NSString *)name {
  if (self = [super init]) {
    versions_ = [[JavaUtilArrayList alloc] init];
    self->name_ = name;
  }
  return self;
}

- (NSString *)getDatabaseName {
  return [NSString stringWithFormat:@"%@.sqlite", name_];
}

- (NSString *)getSimpleName {
  return name_;
}

- (void)copyAllFieldsTo:(FFTDatastoreManager_Database *)other {
  [super copyAllFieldsTo:other];
  other->currentVersion_ = currentVersion_;
  other->name_ = name_;
  other->versions_ = versions_;
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "initWithNSString:", "Database", NULL, 0x1, NULL },
    { "getDatabaseName", NULL, "Ljava.lang.String;", 0x1, NULL },
    { "getSimpleName", NULL, "Ljava.lang.String;", 0x1, NULL },
  };
  static J2ObjcFieldInfo fields[] = {
    { "versions_", NULL, 0x0, "Ljava.util.ArrayList;", NULL,  },
    { "currentVersion_", NULL, 0x0, "Lcom.sponberg.fluid.datastore.DatastoreVersion;", NULL,  },
    { "name_", NULL, 0x12, "Ljava.lang.String;", NULL,  },
  };
  static J2ObjcClassInfo _FFTDatastoreManager_Database = { "Database", "com.sponberg.fluid.datastore", "DatastoreManager", 0x9, 3, methods, 3, fields, 0, NULL};
  return &_FFTDatastoreManager_Database;
}

@end
