//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: src-external/com/eclipsesource/json/JsonParser.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "com/eclipsesource/json/JsonArray.h"
#include "com/eclipsesource/json/JsonNumber.h"
#include "com/eclipsesource/json/JsonObject.h"
#include "com/eclipsesource/json/JsonParser.h"
#include "com/eclipsesource/json/JsonString.h"
#include "com/eclipsesource/json/JsonValue.h"
#include "com/eclipsesource/json/ParseException.h"
#include "java/io/IOException.h"
#include "java/io/Reader.h"
#include "java/io/StringReader.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuilder.h"

@implementation FFTJsonParser

- (id)initWithNSString:(NSString *)string {
  return [self initFFTJsonParserWithJavaIoReader:[[JavaIoStringReader alloc] initWithNSString:string] withInt:[JavaLangMath maxWithInt:FFTJsonParser_MIN_BUFFER_SIZE withInt:[JavaLangMath minWithInt:FFTJsonParser_DEFAULT_BUFFER_SIZE withInt:((int) [((NSString *) nil_chk(string)) length])]]];
}

- (id)initWithJavaIoReader:(JavaIoReader *)reader {
  return [self initFFTJsonParserWithJavaIoReader:reader withInt:FFTJsonParser_DEFAULT_BUFFER_SIZE];
}

- (id)initFFTJsonParserWithJavaIoReader:(JavaIoReader *)reader
                                withInt:(int)buffersize {
  if (self = [super init]) {
    self->reader_ = reader;
    buffer_ = [IOSCharArray arrayWithLength:buffersize];
    line_ = 1;
    captureStart_ = -1;
  }
  return self;
}

- (id)initWithJavaIoReader:(JavaIoReader *)reader
                   withInt:(int)buffersize {
  return [self initFFTJsonParserWithJavaIoReader:reader withInt:buffersize];
}

- (FFTJsonValue *)parse {
  [self read];
  [self skipWhiteSpace];
  FFTJsonValue *result = [self readValue];
  [self skipWhiteSpace];
  if (![self isEndOfText]) {
    @throw [self errorWithNSString:@"Unexpected character"];
  }
  return result;
}

- (FFTJsonValue *)readValue {
  switch (current_) {
    case 'n':
    return [self readNull];
    case 't':
    return [self readTrue];
    case 'f':
    return [self readFalse];
    case '"':
    return [self readString];
    case '[':
    return [self readArray];
    case '{':
    return [self readObject];
    case '-':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    return [self readNumber];
    default:
    @throw [self expectedWithNSString:@"value"];
  }
}

- (FFTJsonArray *)readArray {
  [self read];
  FFTJsonArray *array = [[FFTJsonArray alloc] init];
  [self skipWhiteSpace];
  if ([self readCharWithChar:']']) {
    return array;
  }
  do {
    [self skipWhiteSpace];
    (void) [array addWithFFTJsonValue:[self readValue]];
    [self skipWhiteSpace];
  }
  while ([self readCharWithChar:',']);
  if (![self readCharWithChar:']']) {
    @throw [self expectedWithNSString:@"',' or ']'"];
  }
  return array;
}

- (FFTJsonObject *)readObject {
  [self read];
  FFTJsonObject *object = [[FFTJsonObject alloc] init];
  [self skipWhiteSpace];
  if ([self readCharWithChar:'}']) {
    return object;
  }
  do {
    [self skipWhiteSpace];
    NSString *name = [self readName];
    [self skipWhiteSpace];
    if (![self readCharWithChar:':']) {
      @throw [self expectedWithNSString:@"':'"];
    }
    [self skipWhiteSpace];
    (void) [object addWithNSString:name withFFTJsonValue:[self readValue]];
    [self skipWhiteSpace];
  }
  while ([self readCharWithChar:',']);
  if (![self readCharWithChar:'}']) {
    @throw [self expectedWithNSString:@"',' or '}'"];
  }
  return object;
}

- (NSString *)readName {
  if (current_ != '"') {
    @throw [self expectedWithNSString:@"name"];
  }
  return [self readStringInternal];
}

- (FFTJsonValue *)readNull {
  [self read];
  [self readRequiredCharWithChar:'u'];
  [self readRequiredCharWithChar:'l'];
  [self readRequiredCharWithChar:'l'];
  return FFTJsonValue_get_NULL__();
}

- (FFTJsonValue *)readTrue {
  [self read];
  [self readRequiredCharWithChar:'r'];
  [self readRequiredCharWithChar:'u'];
  [self readRequiredCharWithChar:'e'];
  return FFTJsonValue_get_TRUE__();
}

- (FFTJsonValue *)readFalse {
  [self read];
  [self readRequiredCharWithChar:'a'];
  [self readRequiredCharWithChar:'l'];
  [self readRequiredCharWithChar:'s'];
  [self readRequiredCharWithChar:'e'];
  return FFTJsonValue_get_FALSE__();
}

- (void)readRequiredCharWithChar:(unichar)ch {
  if (![self readCharWithChar:ch]) {
    @throw [self expectedWithNSString:[NSString stringWithFormat:@"'%C'", ch]];
  }
}

- (FFTJsonValue *)readString {
  return [[FFTJsonString alloc] initWithNSString:[self readStringInternal]];
}

- (NSString *)readStringInternal {
  [self read];
  [self startCapture];
  while (current_ != '"') {
    if (current_ == '\\') {
      [self pauseCapture];
      [self readEscape];
      [self startCapture];
    }
    else if (current_ < (int) 0x20) {
      @throw [self expectedWithNSString:@"valid string character"];
    }
    else {
      [self read];
    }
  }
  NSString *string = [self endCapture];
  [self read];
  return string;
}

- (void)readEscape {
  [self read];
  {
    IOSCharArray *hexChars;
    switch (current_) {
      case '"':
      case '/':
      case '\\':
      (void) [((JavaLangStringBuilder *) nil_chk(captureBuffer_)) appendWithChar:(unichar) current_];
      break;
      case 'b':
      (void) [((JavaLangStringBuilder *) nil_chk(captureBuffer_)) appendWithChar:0x0008];
      break;
      case 'f':
      (void) [((JavaLangStringBuilder *) nil_chk(captureBuffer_)) appendWithChar:0x000c];
      break;
      case 'n':
      (void) [((JavaLangStringBuilder *) nil_chk(captureBuffer_)) appendWithChar:0x000a];
      break;
      case 'r':
      (void) [((JavaLangStringBuilder *) nil_chk(captureBuffer_)) appendWithChar:0x000d];
      break;
      case 't':
      (void) [((JavaLangStringBuilder *) nil_chk(captureBuffer_)) appendWithChar:0x0009];
      break;
      case 'u':
      hexChars = [IOSCharArray arrayWithLength:4];
      for (int i = 0; i < 4; i++) {
        [self read];
        if (![self isHexDigit]) {
          @throw [self expectedWithNSString:@"hexadecimal digit"];
        }
        (*IOSCharArray_GetRef(hexChars, i)) = (unichar) current_;
      }
      (void) [((JavaLangStringBuilder *) nil_chk(captureBuffer_)) appendWithChar:(unichar) [JavaLangInteger parseIntWithNSString:[NSString valueOfChars:hexChars] withInt:16]];
      break;
      default:
      @throw [self expectedWithNSString:@"valid escape sequence"];
    }
  }
  [self read];
}

- (FFTJsonValue *)readNumber {
  [self startCapture];
  [self readCharWithChar:'-'];
  int firstDigit = current_;
  if (![self readDigit]) {
    @throw [self expectedWithNSString:@"digit"];
  }
  if (firstDigit != '0') {
    while ([self readDigit]) {
    }
  }
  [self readFraction];
  [self readExponent];
  return [[FFTJsonNumber alloc] initWithNSString:[self endCapture]];
}

- (BOOL)readFraction {
  if (![self readCharWithChar:'.']) {
    return NO;
  }
  if (![self readDigit]) {
    @throw [self expectedWithNSString:@"digit"];
  }
  while ([self readDigit]) {
  }
  return YES;
}

- (BOOL)readExponent {
  if (![self readCharWithChar:'e'] && ![self readCharWithChar:'E']) {
    return NO;
  }
  if (![self readCharWithChar:'+']) {
    [self readCharWithChar:'-'];
  }
  if (![self readDigit]) {
    @throw [self expectedWithNSString:@"digit"];
  }
  while ([self readDigit]) {
  }
  return YES;
}

- (BOOL)readCharWithChar:(unichar)ch {
  if (current_ != ch) {
    return NO;
  }
  [self read];
  return YES;
}

- (BOOL)readDigit {
  if (![self isDigit]) {
    return NO;
  }
  [self read];
  return YES;
}

- (void)skipWhiteSpace {
  while ([self isWhiteSpace]) {
    [self read];
  }
}

- (void)read {
  if ([self isEndOfText]) {
    @throw [self errorWithNSString:@"Unexpected end of input"];
  }
  if (index_ == fill_) {
    if (captureStart_ != -1) {
      (void) [((JavaLangStringBuilder *) nil_chk(captureBuffer_)) appendWithCharArray:buffer_ withInt:captureStart_ withInt:fill_ - captureStart_];
      captureStart_ = 0;
    }
    bufferOffset_ += fill_;
    fill_ = [((JavaIoReader *) nil_chk(reader_)) readWithCharArray:buffer_ withInt:0 withInt:(int) [((IOSCharArray *) nil_chk(buffer_)) count]];
    index_ = 0;
    if (fill_ == -1) {
      current_ = -1;
      return;
    }
  }
  if (current_ == 0x000a) {
    line_++;
    lineOffset_ = bufferOffset_ + index_;
  }
  current_ = IOSCharArray_Get(nil_chk(buffer_), index_++);
}

- (void)startCapture {
  if (captureBuffer_ == nil) {
    captureBuffer_ = [[JavaLangStringBuilder alloc] init];
  }
  captureStart_ = index_ - 1;
}

- (void)pauseCapture {
  int end = current_ == -1 ? index_ : index_ - 1;
  (void) [((JavaLangStringBuilder *) nil_chk(captureBuffer_)) appendWithCharArray:buffer_ withInt:captureStart_ withInt:end - captureStart_];
  captureStart_ = -1;
}

- (NSString *)endCapture {
  int end = current_ == -1 ? index_ : index_ - 1;
  NSString *captured;
  if ([((JavaLangStringBuilder *) nil_chk(captureBuffer_)) sequenceLength] > 0) {
    (void) [captureBuffer_ appendWithCharArray:buffer_ withInt:captureStart_ withInt:end - captureStart_];
    captured = [captureBuffer_ description];
    [captureBuffer_ setLengthWithInt:0];
  }
  else {
    captured = [NSString stringWithCharacters:buffer_ offset:captureStart_ length:end - captureStart_];
  }
  captureStart_ = -1;
  return captured;
}

- (FFTParseException *)expectedWithNSString:(NSString *)expected {
  if ([self isEndOfText]) {
    return [self errorWithNSString:@"Unexpected end of input"];
  }
  return [self errorWithNSString:[NSString stringWithFormat:@"Expected %@", expected]];
}

- (FFTParseException *)errorWithNSString:(NSString *)message {
  int absIndex = bufferOffset_ + index_;
  int column = absIndex - lineOffset_;
  int offset = [self isEndOfText] ? absIndex : absIndex - 1;
  return [[FFTParseException alloc] initWithNSString:message withInt:offset withInt:line_ withInt:column - 1];
}

- (BOOL)isWhiteSpace {
  return current_ == ' ' || current_ == 0x0009 || current_ == 0x000a || current_ == 0x000d;
}

- (BOOL)isDigit {
  return current_ >= '0' && current_ <= '9';
}

- (BOOL)isHexDigit {
  return (current_ >= '0' && current_ <= '9') || (current_ >= 'a' && current_ <= 'f') || (current_ >= 'A' && current_ <= 'F');
}

- (BOOL)isEndOfText {
  return current_ == -1;
}

- (void)copyAllFieldsTo:(FFTJsonParser *)other {
  [super copyAllFieldsTo:other];
  other->buffer_ = buffer_;
  other->bufferOffset_ = bufferOffset_;
  other->captureBuffer_ = captureBuffer_;
  other->captureStart_ = captureStart_;
  other->current_ = current_;
  other->fill_ = fill_;
  other->index_ = index_;
  other->line_ = line_;
  other->lineOffset_ = lineOffset_;
  other->reader_ = reader_;
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "initWithNSString:", "JsonParser", NULL, 0x0, NULL },
    { "initWithJavaIoReader:", "JsonParser", NULL, 0x0, NULL },
    { "initWithJavaIoReader:withInt:", "JsonParser", NULL, 0x0, NULL },
    { "parse", NULL, "Lcom.eclipsesource.json.JsonValue;", 0x0, "Ljava.io.IOException;" },
    { "readValue", NULL, "Lcom.eclipsesource.json.JsonValue;", 0x2, "Ljava.io.IOException;" },
    { "readArray", NULL, "Lcom.eclipsesource.json.JsonArray;", 0x2, "Ljava.io.IOException;" },
    { "readObject", NULL, "Lcom.eclipsesource.json.JsonObject;", 0x2, "Ljava.io.IOException;" },
    { "readName", NULL, "Ljava.lang.String;", 0x2, "Ljava.io.IOException;" },
    { "readNull", NULL, "Lcom.eclipsesource.json.JsonValue;", 0x2, "Ljava.io.IOException;" },
    { "readTrue", NULL, "Lcom.eclipsesource.json.JsonValue;", 0x2, "Ljava.io.IOException;" },
    { "readFalse", NULL, "Lcom.eclipsesource.json.JsonValue;", 0x2, "Ljava.io.IOException;" },
    { "readRequiredCharWithChar:", "readRequiredChar", "V", 0x2, "Ljava.io.IOException;" },
    { "readString", NULL, "Lcom.eclipsesource.json.JsonValue;", 0x2, "Ljava.io.IOException;" },
    { "readStringInternal", NULL, "Ljava.lang.String;", 0x2, "Ljava.io.IOException;" },
    { "readEscape", NULL, "V", 0x2, "Ljava.io.IOException;" },
    { "readNumber", NULL, "Lcom.eclipsesource.json.JsonValue;", 0x2, "Ljava.io.IOException;" },
    { "readFraction", NULL, "Z", 0x2, "Ljava.io.IOException;" },
    { "readExponent", NULL, "Z", 0x2, "Ljava.io.IOException;" },
    { "readCharWithChar:", "readChar", "Z", 0x2, "Ljava.io.IOException;" },
    { "readDigit", NULL, "Z", 0x2, "Ljava.io.IOException;" },
    { "skipWhiteSpace", NULL, "V", 0x2, "Ljava.io.IOException;" },
    { "read", NULL, "V", 0x2, "Ljava.io.IOException;" },
    { "startCapture", NULL, "V", 0x2, NULL },
    { "pauseCapture", NULL, "V", 0x2, NULL },
    { "endCapture", NULL, "Ljava.lang.String;", 0x2, NULL },
    { "expectedWithNSString:", "expected", "Lcom.eclipsesource.json.ParseException;", 0x2, NULL },
    { "errorWithNSString:", "error", "Lcom.eclipsesource.json.ParseException;", 0x2, NULL },
    { "isWhiteSpace", NULL, "Z", 0x2, NULL },
    { "isDigit", NULL, "Z", 0x2, NULL },
    { "isHexDigit", NULL, "Z", 0x2, NULL },
    { "isEndOfText", NULL, "Z", 0x2, NULL },
  };
  static J2ObjcFieldInfo fields[] = {
    { "MIN_BUFFER_SIZE_", NULL, 0x1a, "I", NULL, .constantValue.asInt = FFTJsonParser_MIN_BUFFER_SIZE },
    { "DEFAULT_BUFFER_SIZE_", NULL, 0x1a, "I", NULL, .constantValue.asInt = FFTJsonParser_DEFAULT_BUFFER_SIZE },
    { "reader_", NULL, 0x12, "Ljava.io.Reader;", NULL,  },
    { "buffer_", NULL, 0x12, "[C", NULL,  },
    { "bufferOffset_", NULL, 0x2, "I", NULL,  },
    { "index_", NULL, 0x2, "I", NULL,  },
    { "fill_", NULL, 0x2, "I", NULL,  },
    { "line_", NULL, 0x2, "I", NULL,  },
    { "lineOffset_", NULL, 0x2, "I", NULL,  },
    { "current_", NULL, 0x2, "I", NULL,  },
    { "captureBuffer_", NULL, 0x2, "Ljava.lang.StringBuilder;", NULL,  },
    { "captureStart_", NULL, 0x2, "I", NULL,  },
  };
  static J2ObjcClassInfo _FFTJsonParser = { "JsonParser", "com.eclipsesource.json", NULL, 0x0, 31, methods, 12, fields, 0, NULL};
  return &_FFTJsonParser;
}

@end
